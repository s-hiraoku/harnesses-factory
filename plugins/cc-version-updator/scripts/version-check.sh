#!/bin/bash
#
# version-check.sh
# Detect and notify about new Claude Code versions
#

set -e

# ===== Configuration =====
PLUGIN_DIR="$(cd "$(dirname "$0")/.." && pwd)"
CACHE_DIR="${PLUGIN_DIR}/.cache"
PENDING_UPGRADE_FILE="${CACHE_DIR}/pending-upgrade.json"
CHANGELOG_SUMMARY_FILE="${CACHE_DIR}/changelog-summary.json"

# ===== Initialization =====
mkdir -p "$CACHE_DIR"

# ===== JSON Output =====
output_json() {
  local system_msg="$1"
  local context_msg="${2:-}"

  if [ -n "$context_msg" ]; then
    jq -cn \
      --arg sys "$system_msg" \
      --arg ctx "$context_msg" \
      '{"systemMessage": $sys, "additionalContext": $ctx}'
  else
    jq -cn \
      --arg sys "$system_msg" \
      '{"systemMessage": $sys}'
  fi
}

# ===== Post-upgrade Summary Display =====
show_post_upgrade_summary() {
  if [ ! -f "$CHANGELOG_SUMMARY_FILE" ]; then
    return 1
  fi

  local info=$(cat "$CHANGELOG_SUMMARY_FILE")
  local prev_version=$(echo "$info" | jq -r '.previousVersion // "unknown"')
  local new_version=$(echo "$info" | jq -r '.latestVersion // "unknown"')
  local summary_raw=$(echo "$info" | jq -r '.summary // "Summary not available"')

  # Interpret ANSI escape sequences (\033 -> actual escape character)
  local summary=$(printf '%b' "$summary_raw")

  # Display the summary generated by Claude (with leading newline for formatting)
  local system_msg="
$summary"

  # Context for Claude (for follow-up questions)
  local context_msg="[cc-version-updator] Claude Code has been upgraded from v${prev_version} to v${new_version}. The summary above has been displayed. If the user asks follow-up questions, refer to the changelog-interpreter skill for guidance."

  output_json "$system_msg" "$context_msg"

  # Delete file (display only once)
  rm -f "$CHANGELOG_SUMMARY_FILE"
  return 0
}

# ===== Version Retrieval =====
get_current_version() {
  claude --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1
}

get_latest_version() {
  npm show @anthropic-ai/claude-code version 2>/dev/null
}

# ===== Changelog Retrieval =====
# Get changelogs for all versions between current and latest
get_changelogs() {
  local current_version="$1"
  local latest_version="$2"

  # Fetch all releases from GitHub API
  local releases=$(curl -s "https://api.github.com/repos/anthropics/claude-code/releases?per_page=20" 2>/dev/null)

  if [ -z "$releases" ]; then
    echo "[]"
    return
  fi

  # Filter releases between current and latest versions
  # Returns JSON array of {version, changelog} objects
  echo "$releases" | jq -c --arg current "$current_version" --arg latest "$latest_version" '
    [.[] |
      {
        version: (.tag_name | gsub("^v"; "")),
        changelog: (.body // "No changelog available")
      }
    ] |
    map(select(
      (.version | split(".") | map(tonumber)) as $v |
      ($current | split(".") | map(tonumber)) as $c |
      ($latest | split(".") | map(tonumber)) as $l |
      ($v[0] > $c[0] or ($v[0] == $c[0] and $v[1] > $c[1]) or ($v[0] == $c[0] and $v[1] == $c[1] and $v[2] > $c[2])) and
      ($v[0] < $l[0] or ($v[0] == $l[0] and $v[1] < $l[1]) or ($v[0] == $l[0] and $v[1] == $l[1] and $v[2] <= $l[2]))
    )) |
    sort_by(.version | split(".") | map(tonumber)) |
    reverse
  ' 2>/dev/null || echo "[]"
}

# ===== Save to pending-upgrade.json =====
save_pending_upgrade() {
  local current="$1"
  local latest="$2"
  local changelogs="$3"

  jq -cn \
    --arg prev "$current" \
    --arg latest "$latest" \
    --argjson changelogs "$changelogs" \
    '{
      "previousVersion": $prev,
      "latestVersion": $latest,
      "changelogs": $changelogs,
      "detectedAt": now | todate
    }' > "$PENDING_UPGRADE_FILE"
}

# ===== UI Notification =====
show_update_notification() {
  local current="$1"
  local latest="$2"
  local version_count="$3"

  # ANSI color codes (generate actual escape characters)
  local B=$'\033[1;34m'
  local O=$'\033[38;5;208m'
  local R=$'\033[0m'

  local version_info=""
  if [ "$version_count" -gt 1 ]; then
    version_info=" (${version_count} versions)"
  fi

  local system_msg="
${B}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   New Claude Code version available!

   Current: v${current}  →  Latest: v${latest}${version_info}

   Run ${O}/update-claude ${B}to upgrade.
${B}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${R}"

  local context_msg="A new version v${latest} of Claude Code is available (${version_count} version(s) to upgrade). The current version is v${current}. If the user wants to upgrade, guide them to use the /update-claude command."

  output_json "$system_msg" "$context_msg"
}

# ===== Main Process =====
main() {
  # First, check for post-upgrade summary display
  if show_post_upgrade_summary; then
    exit 0
  fi

  # Get versions
  local CURRENT_VERSION=$(get_current_version)
  local LATEST_VERSION=$(get_latest_version)

  # Compare versions (do nothing if same)
  if [ -z "$LATEST_VERSION" ] || [ "$CURRENT_VERSION" = "$LATEST_VERSION" ]; then
    echo '{}'
    exit 0
  fi

  # New version available - get changelogs for all versions between current and latest
  local CHANGELOGS=$(get_changelogs "$CURRENT_VERSION" "$LATEST_VERSION")

  # Count how many versions are being updated
  local VERSION_COUNT=$(echo "$CHANGELOGS" | jq 'length')
  if [ -z "$VERSION_COUNT" ] || [ "$VERSION_COUNT" = "0" ]; then
    VERSION_COUNT=1
  fi

  # Save to pending-upgrade.json (for /upgrade skill)
  save_pending_upgrade "$CURRENT_VERSION" "$LATEST_VERSION" "$CHANGELOGS"

  # Display notification in UI
  show_update_notification "$CURRENT_VERSION" "$LATEST_VERSION" "$VERSION_COUNT"

  exit 0
}

main
